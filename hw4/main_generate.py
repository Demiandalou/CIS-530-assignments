# -*- coding: utf-8 -*-
"""char-rnn-generation.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1pGom6pS27oXOLfwp524h5vbJRVtXOXT_

![](https://i.imgur.com/eBRPvWB.png)

# Practical PyTorch: Generating Shakespeare with a Character-Level RNN

[In the RNN classification tutorial](https://github.com/spro/practical-pytorch/blob/master/char-rnn-classification/char-rnn-classification.ipynb) we used a RNN to classify text one character at a time. This time we'll generate text one character at a time.

```
> python generate.py -n 500

PAOLTREDN:
Let, yil exter shis owrach we so sain, fleas,
Be wast the shall deas, puty sonse my sheete.

BAUFIO:
Sirh carrow out with the knonuot my comest sifard queences
O all a man unterd.

PROMENSJO:
Ay, I to Heron, I sack, againous; bepear, Butch,
An as shalp will of that seal think.

NUKINUS:
And house it to thee word off hee:
And thou charrota the son hange of that shall denthand
For the say hor you are of I folles muth me?
```

This one might make you question the series title &mdash; "is that really practical?" However, these sorts of generative models form the basis of machine translation, image captioning, question answering and more. See the [Sequence to Sequence Translation tutorial](https://github.com/spro/practical-pytorch/blob/master/seq2seq-translation/seq2seq-translation.ipynb) for more on that topic.

# Recommended Reading

I assume you have at least installed PyTorch, know Python, and understand Tensors:

* http://pytorch.org/ For installation instructions
* [Deep Learning with PyTorch: A 60-minute Blitz](https://github.com/pytorch/tutorials/blob/master/Deep%20Learning%20with%20PyTorch.ipynb) to get started with PyTorch in general
* [jcjohnson's PyTorch examples](https://github.com/jcjohnson/pytorch-examples) for an in depth overview
* [Introduction to PyTorch for former Torchies](https://github.com/pytorch/tutorials/blob/master/Introduction%20to%20PyTorch%20for%20former%20Torchies.ipynb) if you are former Lua Torch user

It would also be useful to know about RNNs and how they work:

* [The Unreasonable Effectiveness of Recurrent Neural Networks](http://karpathy.github.io/2015/05/21/rnn-effectiveness/) shows a bunch of real life examples
* [Understanding LSTM Networks](http://colah.github.io/posts/2015-08-Understanding-LSTMs/) is about LSTMs specifically but also informative about RNNs in general

Also see these related tutorials from the series:

* [Classifying Names with a Character-Level RNN](https://github.com/spro/practical-pytorch/blob/master/char-rnn-classification/char-rnn-classification.ipynb) uses an RNN for classification
* [Generating Names with a Conditional Character-Level RNN](https://github.com/spro/practical-pytorch/blob/master/conditional-char-rnn/conditional-char-rnn.ipynb) builds on this model to add a category as input

# Prepare data

The file we are using is a plain text file. We turn any potential unicode characters into plain ASCII by using the `unidecode` package (which you can install via `pip` or `conda`).
"""

# from google.colab import drive
# drive.mount('/content/gdrive')
# lotr_path = '/content/gdrive/My Drive/cis530_hw6/lotr.txt'

# !wget https://raw.githubusercontent.com/karpathy/char-rnn/master/data/tinyshakespeare/input.txt -O shakespeare.txt
# !wget https://raw.githubusercontent.com/rdeese/tunearch-corpus/master/all-abcs.txt -O ABC_music.txt
# !wget https://raw.githubusercontent.com/ryanmcdermott/trump-speeches/master/speeches.txt -O trump.txt
# !wget http://www.gutenberg.org/files/31100/31100.txt -O Jane_austen.txt
# !pip3 install unidecode

import unidecode
import string
import random
import re
lotr_path = 'lotr.txt'
all_characters = string.printable
n_characters = len(all_characters)

# file = unidecode.unidecode(open('shakespeare.txt').read())
# file_len = len(file)
# print('file_len =', file_len)
abc_file = unidecode.unidecode(open('ABC_music.txt').read())
abc_file_len = len(abc_file)
print('abc_file_len =', abc_file_len)
# trump_file = unidecode.unidecode(open('trump.txt').read())
# trump_file_len = len(trump_file)
# print('trump_file_len =', trump_file_len)
ja_file = unidecode.unidecode(open('Jane_austen.txt',errors='ignore').read())
ja_file_len = len(ja_file)
print('ja_file_len =', ja_file_len)
lotr_file = unidecode.unidecode(open(lotr_path,encoding='utf-8',errors='ignore').read())
lotr_file_len = len(lotr_file)
print('lotr_file_len =', lotr_file_len)

file = unidecode.unidecode(open('Jane_austen.txt',errors='ignore').read())

"""To make inputs out of this big string of data, we will be splitting it into chunks."""

# chunk_len = 200

def random_chunk(f=file, chunk_len=200):
    # start_index = random.randint(0, file_len - chunk_len)
    start_index = random.randint(0, len(f) - chunk_len)
    end_index = start_index + chunk_len + 1
    return f[start_index:end_index]

print(random_chunk(lotr_file),'\n')
print(len(random_chunk(lotr_file)))

"""# Build the Model

This model will take as input the character for step $t_{-1}$ and is expected to output the next character $t$. There are three layers - one linear layer that encodes the input character into an internal state, one GRU layer (which may itself have multiple layers) that operates on that internal state and a hidden state, and a decoder layer that outputs the probability distribution.
"""

import torch
import torch.nn as nn
from torch.autograd import Variable

class RNN(nn.Module):
    def __init__(self, input_size, hidden_size, output_size, n_layers=1):
        super(RNN, self).__init__()
        self.input_size = input_size
        self.hidden_size = hidden_size
        self.output_size = output_size
        self.n_layers = n_layers
        
        self.encoder = nn.Embedding(input_size, hidden_size)
        self.gru = nn.GRU(hidden_size, hidden_size, n_layers)
        self.decoder = nn.Linear(hidden_size, output_size)
    
    def forward(self, input, hidden):
        input = self.encoder(input.view(1, -1))
        output, hidden = self.gru(input.view(1, 1, -1), hidden)
        output = self.decoder(output.view(1, -1))
        return output, hidden

    def init_hidden(self):
        return Variable(torch.zeros(self.n_layers, 1, self.hidden_size))

"""# Inputs and Targets

Each chunk will be turned into a tensor, specifically a `LongTensor` (used for integer values), by looping through the characters of the string and looking up the index of each character in `all_characters`.
"""

# Turn string into list of longs
def char_tensor(string):
    tensor = torch.zeros(len(string)).long()
    for c in range(len(string)):
        tensor[c] = all_characters.index(string[c])
    return Variable(tensor)

print(char_tensor('abcDEF'))

"""Finally we can assemble a pair of input and target tensors for training, from a random chunk. The input will be all characters *up to the last*, and the target will be all characters *from the first*. So if our chunk is "abc" the input will correspond to "ab" while the target is "bc"."""

def random_training_set():    
    chunk = random_chunk(file)
    inp = char_tensor(chunk[:-1])
    target = char_tensor(chunk[1:])
    return inp, target
# print(random_training_set())

"""# Evaluating

To evaluate the network we will feed one character at a time, use the outputs of the network as a probability distribution for the next character, and repeat. To start generation we pass a priming string to start building up the hidden state, from which we then generate one character at a time.
"""

def evaluate(prime_str='A', predict_len=100, temperature=0.8):
    hidden = decoder.init_hidden()
    prime_input = char_tensor(prime_str)
    predicted = prime_str

    # Use priming string to "build up" hidden state
    for p in range(len(prime_str) - 1):
        _, hidden = decoder(prime_input[p], hidden)
    inp = prime_input[-1]
    
    for p in range(predict_len):
        output, hidden = decoder(inp, hidden)
        
        # Sample from the network as a multinomial distribution
        output_dist = output.data.view(-1).div(temperature).exp()
        top_i = torch.multinomial(output_dist, 1)[0]
        
        # Add predicted character to string and use as next input
        predicted_char = all_characters[top_i]
        predicted += predicted_char
        inp = char_tensor(predicted_char)

    return predicted

def perplexity_score(target_seq, prime_str='A', predict_len=100, temperature=0.8):
    criterion = nn.CrossEntropyLoss()
    target = char_tensor(target_seq)
    hidden = decoder.init_hidden()
    prime_input = char_tensor(prime_str)
    predicted = prime_str
    loss = 0
    for p in range(len(prime_str) - 1):
        output, hidden = decoder(prime_input[p], hidden)
        # loss += criterion(output, target[[0]])
    inp = prime_input[-1]
    # print(target)
    for p in range(predict_len):
        output, hidden = decoder(inp, hidden)
        loss += criterion(output, target[[p]])
        # Sample from the network as a multinomial distribution
        output_dist = output.data.view(-1).div(temperature).exp()
        top_i = torch.multinomial(output_dist, 1)[0]
        
        # Add predicted character to string and use as next input
        predicted_char = all_characters[top_i]
        predicted += predicted_char
        inp = char_tensor(predicted_char)
    return predicted, loss/predict_len
    # return predicted, loss

# model_path = 'model_generate'
# n_layers = 1
# hidden_size = 100
# decoder = RNN(n_characters, hidden_size, n_characters, n_layers)
# decoder.load_state_dict(torch.load(model_path))

# cur_chunk = random_chunk(file,len(file))
import time
import numpy as np

# start = time.time()
# print(len(abc_file))
# total = []
# for i in range(100000,len(abc_file),100000):
#   print('i',i,end='')
#   cur_chunk = abc_file[i-100000:i]
#   pred,loss = perplexity_score(cur_chunk[1:],predict_len = len(cur_chunk)-1) # prime_str=cur_chunk[0], 
#   total.append(loss.item())
#   print('time',time.time()-start)
# print(np.mean(total)) # 

# cur_chunk = random_chunk(file)
# pred,loss = perplexity_score(cur_chunk[1:],predict_len = 200)
# print(loss)


"""# Training

A helper to print the amount of time passed:
"""

import time, math

def time_since(since):
    s = time.time() - since
    m = math.floor(s / 60)
    s -= m * 60
    return '%dm %ds' % (m, s)

"""The main training function"""

def train(inp, target):
    hidden = decoder.init_hidden()
    decoder.zero_grad()
    loss = 0

    for c in range(chunk_len):
        output, hidden = decoder(inp[c], hidden)
        # print(output.shape)
        # print(target[[c]].shape)
        loss += criterion(output, target[[c]])

    loss.backward()
    decoder_optimizer.step()

    # return loss.data[0] / chunk_len
    return loss.data / chunk_len

def perplexity_score_whole_dataset():
    start = time.time()
    print(len(lotr_file))
    total = []
    for i in range(10000,len(lotr_file),10000):
      print(i)
      cur_chunk = lotr_file[i-10000:i]
      pred,loss = perplexity_score(cur_chunk[1:],predict_len = len(cur_chunk)-1) # prime_str=cur_chunk[0], 
      total.append(loss.item())
      print(time.time()-start)
    print(np.mean(total)) # 6.23

    start = time.time()
    print(len(abc_file))
    total = []
    for i in range(100000,len(abc_file),100000):
      print('i',i,end='')
      cur_chunk = abc_file[i-100000:i]
      pred,loss = perplexity_score(cur_chunk[1:],predict_len = len(cur_chunk)-1) # prime_str=cur_chunk[0], 
      total.append(loss.item())
      print('time',time.time()-start)
    print(np.mean(total)) # 10.06

print(len(file))
print(len(ja_file))

if __name__ == '__main__':
    from argparse import ArgumentParser
    parser = ArgumentParser()
    parser.add_argument('--train', default=0, action='store_true',
                            help='')
    parser.add_argument('--plot', default=0, action='store_true',
                            help='')
    parser.add_argument('--eval', default=0, action='store_true',
                            help='')
    parser.add_argument('--perplexity', default=0, action='store_true',
                            help='')
    args = parser.parse_args()

    if args.train:
        """Then we define the training parameters, instantiate the model, and start training:"""

        n_epochs = 2000
        print_every = 100
        plot_every = 10
        hidden_size = 100
        n_layers = 1
        lr = 0.005
        chunk_len = 200

        decoder = RNN(n_characters, hidden_size, n_characters, n_layers)
        decoder_optimizer = torch.optim.Adam(decoder.parameters(), lr=lr)
        criterion = nn.CrossEntropyLoss()

        start = time.time()
        all_losses = []
        loss_avg = 0

        for epoch in range(1, n_epochs + 1):
            loss = train(*random_training_set())       
            loss_avg += loss

            if epoch % print_every == 0:
                print('[%s (%d %d%%) %.4f]' % (time_since(start), epoch, epoch / n_epochs * 100, loss))
                print(evaluate('Wh', 100), '\n')

            if epoch % plot_every == 0:
                all_losses.append(loss_avg / plot_every)
                loss_avg = 0
        torch.save(decoder.state_dict(), 'model_generate.pth')

    if args.train and args.plot:
        """# Plotting the Training Losses

        Plotting the historical loss from all_losses shows the network learning:
        """

        # Commented out IPython magic to ensure Python compatibility.
        import matplotlib.pyplot as plt
        import matplotlib.ticker as ticker
        # %matplotlib inline

        plt.figure()
        plt.plot(all_losses)
        plt.show()
    if args.eval:

        """# Evaluating at different "temperatures"
        In the `evaluate` function above, every time a prediction is made the outputs are divided by the "temperature" argument passed. Using a higher number makes all actions more equally likely, and thus gives us "more random" outputs. Using a lower value (less than 1) makes high probabilities contribute more. As we turn the temperature towards zero we are choosing only the most likely outputs.
        We can see the effects of this by adjusting the `temperature` argument.
        """
        model_path = 'model_generate'
        n_layers = 1
        hidden_size = 100
        decoder = RNN(n_characters, hidden_size, n_characters, n_layers)
        decoder.load_state_dict(torch.load(model_path))
        print('tmperature = 0.8')
        print(evaluate('Th', 200, temperature=0.8))

        """Lower temperatures are less varied, choosing only the more probable outputs:"""
        print('tmperature = 0.2')
        print(evaluate('Th', 200, temperature=0.2))

        """Higher temperatures more varied, choosing less probable outputs:"""
        print('tmperature = 1.4')
        print(evaluate('Th', 200, temperature=1.4))

    if args.perplexity:
        print('perplexity score on abc dataset (dissimilar)')
        cur_chunk = random_chunk(abc_file)
        pred,loss = perplexity_score(cur_chunk[1:],predict_len = 200)
        print(2**loss)

        print('perplexity score on lotr dataset (similar)')
        cur_chunk = random_chunk(lotr_file)
        pred,loss = perplexity_score(cur_chunk[1:],predict_len = 200)
        print(2**loss)


"""# Exercises

* Train with your own dataset, e.g.
    * Text from another author
    * Blog posts
    * Code
* Increase number of layers and network size to get better results

**Next**: [Generating Names with a Conditional Character-Level RNN](https://github.com/spro/practical-pytorch/blob/master/conditional-char-rnn/conditional-char-rnn.ipynb)
"""